# MRO у Python працює наступним чином:

# Шукає атрибут серед атрибутів самого класу. Саме завдяки цьому ви можете "перевизначати" батьківські атрибути.
# Шукає атрибут у першого з батьків (той, що вказаний першим у списку батьків).
# Шукає атрибут у наступного батька у списку батьків, доки такі є.
# Шукає атрибут у батьках першого батька.
# Повторює пункт 4 для всіх батьків.
# Викликає виняток, що атрибут не знайдено.

# Пошуки закінчуються, як тільки атрибут знайдено.

#Ви можете переглянути MRO для будь-якого класу використовуючи метод mro() або атрибут __mro__. Наприклад:
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.mro())  # Виведе порядок розв'язання методів для класу D


# Зверніть увагу що виклик відбувається на самому класі, 
# а не екземплярі класу. У цьому прикладі виведення буде наступним:
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

# Це порядок MRO для класу D який означає, що Python спочатку шукатиме методи в D, потім у B, 
# за ними в C, потім в A, і, нарешті, в вбудованому базовому класі object, який є предком всіх класів.
